Murex is being built with a strong emphasis on formal, mathematical methods. Even still, formal methods are seen as "too academic" and "useless," but I disagree. Certainly, it is uncessecary and inefficient for programmers to understand and use the theory behind the language for everyday tasks. On the other hand, if the designer understands the theory correctly, the everyday programmer is aided in their task to suych an extent that solving problems, even the difficult ones, becomes a joy. If the designer does not know the theory, they will cause pain to their users, and if they try to be creative without understanding the theory, their users will cry out for better days. Let's see this in action.

Some languages are beloved and others despised by polyglot programmers. Not every polyglot has the same tastes, but there are general trends. The biggest trend is that languages which are based in theory are beloved and those which resist formalization are despised.

Lisp began life as simply a formal notation. It later became a programming language. Its formal basis is extremely small and elegant. It has been loved since it was born, and will likely continue to be loved for generations.
ML was invented as a meta-language for logic, and inherited that style of thought. SML, its descendant, is defined not just by an international standard, but by cold, hard mathematics. Its advocates are die-hard.
Haskell had as its goal, in part, to serve as a research platform for theory. Though it is not formalized, the theory behind it is clear.
Smalltalk was derived directly from the actor model and relies on only a single concept: sending a message full of values from one value to another.
C is a simple language with a small, clear theory. Albeit, the theory is a low-level theory, unconcerned with such abstract concepts as functions and polymorphism, but there is a theory nonetheless. Despite its problems, it remains as the preferred systems programming language.

Java, Javascipt, C++, and PHP are all despised. Their warts are numerous; their semantics, once painstakingly discovered, are convoluted and untracable; their array of concepts vast and the methods by which they may be represented needlessly multifarious.

Algol once had a theory, but in the rush to produce Algol68, its theory was overwhelemed by a rush of new tacked-on "features," and the language dissapeared into derision. Its legacy remains with us, however, and more than just curly-braces: its formal method of specifying grammar, BNF, was so successful that it is understood by any programmer today, almost intuitively.

The fascinating thing is that despised languages are commonly-used. I speculate that it is easy to do beginner things in poorly-designed languages, and that this is the trap. Once a beginner programmer is inculcated, thay cannot escape the cult without great difficulty. When the beginner moves to building large systems, most people will not self-reflect, but work harder and apply more self-discipline. When an enterprise gets behind one of these langauges, perhaps because there are many programmers available, the fad spirals out of control, and it is too late, too much investment has been made, to reverse the popularity. Again, the instict for an enterprise is not to self-reflect, but to hire more programmers and discipline them more strictly.


C is an interesting case. Is it even a high-level language? It clearly isn't portable assembly, having neither access to the stack or registers. Nevertheless, C does not add any serious features to assembly; it merely blessed concepts such as the procedure, local variable, looping and conditionals.  Aside from automation, C is a restriction of assembly languages. It is not "portable assembly," but niether is it high-level; it is simply a low-level language.